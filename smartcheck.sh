#!/bin/bash
###eksctl scale nodegroup --cluster=managed-smartcheck --nodes=1 --name=<nodegroupName>
printf '%s\n' "---------------------------"
printf '%s\n' " Deep Security Smart Check "
printf '%s\n' "---------------------------"


#Deploy Smartcheck
#------------------
HELM_DEPLOYMENTS=
if [[ "`helm list -n ${DSSC_NAMESPACE} -o json | jq -r '.[].name'`" =~ 'deepsecurity-smartcheck' ]];
  then
    printf '%s\n' "Found exising Smart Check deployment"
    printf '%s\n' "Rebuilding overrides.yml"
    cat <<EOF >./overrides.yml
# This file is (re-) generated by code.
# Any manual changes will be overwritten.
#
##
## Default value: (none)
activationCode: '${DSSC_AC}'
auth:
  ## secretSeed is used as part of the password generation process for
  ## all auto-generated internal passwords, ensuring that each installation of
  ## Deep Security Smart Check has different passwords.
  ##
  ## Default value: {must be provided by the installer}
  secretSeed: 'just_anything-really_anything'
  ## userName is the name of the default administrator user that the system creates on startup.
  ## If a user with this name already exists, no action will be taken.
  ##
  ## Default value: administrator
  ## userName: administrator
  userName: '${DSSC_USERNAME}'
  ## password is the password assigned to the default administrator that the system creates on startup.
  ## If a user with the name 'auth.userName' already exists, no action will be taken.
  ##
  ## Default value: a generated password derived from the secretSeed and system details
  ## password: # autogenerated
  password: '${DSSC_TEMPPW}'
EOF

    cat <<EOF >>./overrides.yml
registry:
  ## Enable the built-in registry for pre-registry scanning.
  ##
  ## Default value: false
  enabled: true
    ## Authentication for the built-in registry
  activationCode: '${DSSC_AC}'
  auth:
    ## User name for authentication to the registry
    ##
    ## Default value: empty string
    username: '${DSSC_REGUSER}'
    ## Password for authentication to the registry
    ##
    ## Default value: empty string
    password: '${DSSC_REGPASSWORD}'
    ## The amount of space to request for the registry data volume
    ##
    ## Default value: 5Gi
  dataVolume:
    sizeLimit: 10Gi
certificate:
  secret:
    name: k8s-certificate
    certificate: tls.crt
    privateKey: tls.key
EOF


    #####printf '%s\n' "Upgrading SmartCheck ... "
    #####helm upgrade -n ${DSSC_NAMESPACE} --values overrides.yml deepsecurity-smartcheck https://github.com/deep-security/smartcheck-helm/archive/1.2.47.tar.gz
    cat cloudOneCredentials.txt
  else
    #get certificate for internal registry
    #-------------------------------------
    #create req.conf
    #printf '%s' "Creating req.conf..."
cat << EOF >./req.conf
# This file is (re-)generated by code.
# Any manual changes will be overwritten.
[req]
  distinguished_name=req
[san]
  subjectAltName=DNS:*.cloudapp.azure.com
EOF

    NAMESPACES=`kubectl get namespaces`
    if [[ "$NAMESPACES" =~ "${DSSC_NAMESPACE}" ]]; then
      printf '%s\n' "Reusing existing namespace \"${DSSC_NAMESPACE}\""
    else
      printf '%s' "Creating namespace smartcheck..."
      kubectl create namespace ${DSSC_NAMESPACE}
    fi

    #printf '%s' "Creating certificate for loadballancer..."
    #openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes -keyout k8s.key -out k8s.crt -subj "/CN=*.cloudapp.azure.com" -extensions san -config req.conf

    #printf '%s' "Creating secret with keys in Kubernetes..."
    #kubectl create secret tls k8s-certificate --cert=k8s.crt --key=k8s.key --dry-run=true -n ${DSSC_NAMESPACE} -o yaml | kubectl apply -f -


    # Create overrides.yml
    #-------------------------
    printf '%s\n' "Creating overrides.yml file"

    cat <<EOF >./overrides.yml
# This file is (re-) generated by code.
# Any manual changes will be overwritten.
#
##
## Default value: (none)
activationCode: '${DSSC_AC}'
auth:
  ## secretSeed is used as part of the password generation process for
  ## all auto-generated internal passwords, ensuring that each installation of
  ## Deep Security Smart Check has different passwords.
  ##
  ## Default value: {must be provided by the installer}
  secretSeed: 'just_anything-really_anything'
  ## userName is the name of the default administrator user that the system creates on startup.
  ## If a user with this name already exists, no action will be taken.
  ##
  ## Default value: administrator
  ## userName: administrator
  userName: '${DSSC_USERNAME}'
  ## password is the password assigned to the default administrator that the system creates on startup.
  ## If a user with the name 'auth.userName' already exists, no action will be taken.
  ##
  ## Default value: a generated password derived from the secretSeed and system details
  ## password: # autogenerated
  password: '${DSSC_TEMPPW}'
EOF

    printf '%s\n' "Deploying Helm chart... "
    #helm install -n ${DSSC_NAMESPACE} --values overrides.yml deepsecurity-smartcheck https://github.com/deep-security/smartcheck-helm/archive/master.tar.gz > /dev/null
    helm install -n ${DSSC_NAMESPACE} --values overrides.yml deepsecurity-smartcheck https://github.com/deep-security/smartcheck-helm/archive/1.2.47.tar.gz > /dev/null

    printf '%s' "Waiting for Smart Check deployments"
    SMARTCHECK_DEPLOYMENTS=$(kubectl -n smartcheck get deployments | grep -c "/")
    while [ $(kubectl -n smartcheck get deployments | grep -cE "1/1|2/2") -ne ${SMARTCHECK_DEPLOYMENTS} ]
    do
      printf '%s' "."
      sleep 2
    done
    printf ' - %s\n' "active"

    DSSC_HOST=''
    printf '%s \n' "Waiting for loadBalancer to come online"
    while [[ "$DSSC_HOST" == '' ]];do
      export DSSC_HOST=`kubectl get svc -n ${DSSC_NAMESPACE} proxy -o jsonpath='{.status.loadBalancer.ingress[0].ip}'`
      sleep 10
    done
    #  echo SmartCheck URL will be https://${DSSC_HOST}
    #echo Username: $(kubectl get  secrets -o jsonpath='{ .data.userName }' deepsecurity-smartcheck-auth | base64 --decode)
    #echo Password: $(kubectl get  secrets -o jsonpath='{ .data.password }' deepsecurity-smartcheck-auth | base64 --decode)
    printf '%s \n' "Waiting for Smart Check to come online (2): ."
    DSSC_BEARERTOKEN=''
    while [[ "$DSSC_BEARERTOKEN" == '' ]];do
      #kubectl get services -n smartcheck
      #kubectl get service proxy -n smartcheck
      echo "DEBUG: doing first curl (2)"
      DUMMY=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_TEMPPW}\"}}"`
      #echo "DEBUG doing second curl (2)"
      export DSSC_USERID=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_TEMPPW}\"}}" | jq '.user.id' | tr -d '"' 2>/dev/null`

      printf '%s \n' "DSSC_USERID=${DSSC_USERID}"
      echo "DEBUG doing third curl (2)"
      DSSC_BEARERTOKEN=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_TEMPPW}\"}}" | jq '.token' | tr -d '"'
      #debug  2>/dev/null`
      printf '%s \n' "Bearertoken=$DSSC_BEARERTOKEN"
    done
    #printf '%s \n' "Bearer Token = ${DSSC_BEARERTOKEN} "
    #printf '%s \n' "DSSC_USERID  = ${DSSC_USERID} "

    #check certificate at loadbalancer
    #openssl s_client -showcerts -connect $DSSC_HOST:443

    #4.: do mandatory initial password change
    #----------------------------------------
    printf '%s \n' "Doing initial (required) password change"
    DUMMY=`curl -s -k -X POST https://${DSSC_HOST}/api/users/${DSSC_USERID}/password -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -H "authorization: Bearer ${DSSC_BEARERTOKEN}" -d "{  \"oldPassword\": \"${DSSC_TEMPPW}\", \"newPassword\": \"${DSSC_PASSWORD}\"  }"`

    #smartcheck redeploy, but now that we know the IP ( ${DSSC_HOST} ) we can create the correct certificate

    printf '%s \n' "Upgrading SmartCheck to use the new with certificate "
    printf '$s \n' "Modifying overrides.yml"
    cat <<EOF >>./overrides.yml
registry:
  ## Enable the built-in registry for pre-registry scanning.
  ##
  ## Default value: false
  enabled: true
    ## Authentication for the built-in registry
  auth:
    ## User name for authentication to the registry
    ##
    ## Default value: empty string
    username: '${DSSC_REGUSER}'
    ## Password for authentication to the registry
    ##
    ## Default value: empty string
    password: '${DSSC_REGPASSWORD}'
    ## The amount of space to request for the registry data volume
    ##
    ## Default value: 5Gi
  dataVolume:
    sizeLimit: 10Gi
certificate:
  secret:
    name: k8s-certificate
    certificate: tls.crt
    privateKey: tls.key
EOF


    #create req.conf
    #printf '%s' "Creating req.conf..."
cat <<EOF >./req.conf
# This file is (re-)generated by code.
# Any manual changes will be overwritten.
[req]
  distinguished_name=req
[san]
  subjectAltName=DNS:${DSSC_HOST}.nip.io
EOF

    #debug
    cat ./req.conf

    printf '%s' "Creating certificate for loadballancer..."
    openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes -keyout k8s.key -out k8s.crt -subj "/CN=$DSSC_HOST.nip.io" -extensions san -config req.conf

    openssl x509 -in k8s.crt  -text | grep 'Subject: CN='

    printf '%s' "Creating secret with keys in Kubernetes..."
    kubectl create secret tls k8s-certificate --cert=k8s.crt --key=k8s.key --dry-run=true -n ${DSSC_NAMESPACE} -o yaml | kubectl apply -f -


    printf '%s\n' "Upgrading SmartCheck with new Certificate... "
    helm upgrade -n ${DSSC_NAMESPACE} --values overrides.yml deepsecurity-smartcheck https://github.com/deep-security/smartcheck-helm/archive/1.2.47.tar.gz
    ###debug > /dev/null
fi


printf '%s' "Waiting for Smart Check deployments"
SMARTCHECK_DEPLOYMENTS=$(kubectl -n smartcheck get deployments | grep -c "/")
while [ $(kubectl -n smartcheck get deployments | grep -cE "1/1|2/2") -ne ${SMARTCHECK_DEPLOYMENTS} ]
do
  printf '%s' "."
  sleep 2
done
printf ' - %s\n' "active"

DSSC_HOST=''
printf '%s \n' "Waiting for loadBalancer to come online"
while [[ "$DSSC_HOST" == '' ]];do
  export DSSC_HOST=`kubectl get svc -n ${DSSC_NAMESPACE} proxy -o jsonpath='{.status.loadBalancer.ingress[0].ip}'`.nip.io
  echo $DSSC_HOST
  sleep 10
done
#  echo SmartCheck URL will be https://${DSSC_HOST}
#echo Username: $(kubectl get  secrets -o jsonpath='{ .data.userName }' deepsecurity-smartcheck-auth | base64 --decode)
#echo Password: $(kubectl get  secrets -o jsonpath='{ .data.password }' deepsecurity-smartcheck-auth | base64 --decode)
printf '%s \n' "Waiting for Smart Check to come online: ."
DSSC_BEARERTOKEN=''
while [[ "$DSSC_BEARERTOKEN" == '' ]];do
  #kubectl get services -n smartcheck
  #kubectl get service proxy -n smartcheck
  #echo "DEBUG: doing first curl"
  DUMMY=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_PASSWORD}\"}}"`
  #echo "DEBUG doing second curl"
  DSSC_USERID=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_PASSWORD}\"}}" | jq '.user.id' | tr -d '"' 2>/dev/null`
  #printf '%s \n' "DSSC_USERID=${DSSC_USERID}"
  #printf '%s' userid=$DSSC_USERID
  #echo "DEBUG doing third curl"
  DSSC_BEARERTOKEN=`curl -s -k -X POST https://${DSSC_HOST}/api/sessions -H "Content-Type: application/json"  -H "Api-Version: 2018-05-01" -H "cache-control: no-cache" -d "{\"user\":{\"userid\":\"${DSSC_USERNAME}\",\"password\":\"${DSSC_PASSWORD}\"}}" | jq '.token' | tr -d '"' 2>/dev/null`
  printf '%s \n' "Bearertoken=$DSSC_BEARERTOKEN"
done

printf '%s \n' "Bearertoken=$DSSC_BEARERTOKEN" printf '%s \n' "You can login: "
printf '%s \n' "+-------------------------------------"
printf '%s \n' "|     URL: https://${DSSC_HOST}"
printf '%s \n' "|     user: ${DSSC_USERNAME}"
printf '%s \n' "|     passw: ${DSSC_PASSWORD}"
printf '%s \n' "+-------------------------------------" #saving vars
printf '%s \n' "export DSSC_HOST=${DSSC_HOST}" > cloudOneCredentials.txt
printf '%s \n' "export DSSC_USERNAME=${DSSC_USERNAME}" >> cloudOneCredentials.txt
printf '%s \n' "export DSSC_PASSWORD=${DSSC_PASSWORD}" >> cloudOneCredentials.txt
